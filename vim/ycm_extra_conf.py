import os
import ycm_core

SOURCE_EXTENSIONS = [".cpp", ".cxx", ".cc", ".c", ".m", ".mm"]
HEADER_EXTENSIONS = [".hpp", ".hxx", ".hh", ".h", ".inl", ".impl"]
PATH_FLAGS = ["-I", "-iquote", "-isystem", "--sysroot="]

def commonFlags():
    return [
        "-Wall",
        "-Wextra",
        "-Werror",
        "-Weffc++",
        "--pipe",
        "-std=c++14",
        "-x", "c++",
        "-DUSE_CLANG_COMPLETER",
    ]

def systemIncludePaths():
    return [
        "/usr/include",
        "/usr/local/include",
        "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1",
        "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/6.0/include",
        "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include",
        "/System/Library/Frameworks",
        "/System/Library/Frameworks/Python.framework/Headers",
    ]

def localIncludePaths(filename):
    local_directory = os.path.dirname(filename)
    include_directory = local_directory
    while include_directory and os.path.basename(include_directory) != "include":
        include_directory = os.path.dirname(include_directory)

    paths = [local_directory]
    if include_directory:
        paths.append(include_directory)
    return paths

def includeFlags(flag, paths):
    return reduce(lambda flags, path: flags.extend([flag, path]),
                  [path for path in set(paths) if os.path.exists(path)],
                  [])

def defaultFlags(filename):
    return commonFlags() + \
            includeFlags("-isystem", systemIncludePaths()) + \
            includeFlags("-iquote", localIncludePaths(filename))

gDatabaseSingletonMap = {}
kDatabaseFileBasename = "compile_commands.json"

def databaseSingletonForFile(filename):
    def findDatabaseDirectory(directory):
        while directory:
            db_file = os.path.join(directory, kDatabaseFileBasename)
            if os.path.exists(db_file):
                return directory
        return None

    db_dir = findDatabaseDirectory(os.path.dirname(filename))
    if not db_dir:
        return None

    if db_dir not in gDatabaseSingletonMap:
        gDatabaseSingletonMap[db_dir] = ycm_core.CompilationDatabase(db_dir)
    return gDatabaseSingletonMap[db_dir]

def getCompilationInfoForFile(filename):
    database = databaseSingletonForFile(filename)
    if not database:
        return None

    root, extension = os.path.splitext(filename)

    # The compilation_commands.json file generated by CMake does not have
    # entries for header files. So we do our best by asking the db for flags for
    # a corresponding source file, if any. If one exists, the flags for that
    # file should be good enough.
    if extension not in HEADER_EXTENSIONS:
        return database.GetCompilationInfoForFile(filename)

    for replacement_extension in SOURCE_EXTENSIONS:
        replacement_file = root + replacement_extension
        if os.path.exists(replacement_file):
            info = database.GetCompilationInfoForFile(replacement_file)
            if info.compiler_flags_:
                return info
    return None

def getFileFlagsAndWorkingDirectory(filename):
    info = getCompilationInfoForFile(filename)
    if info:
        return info.compiler_flags_, info.compiler_working_dir_
    return defaultFlags(filename), os.path.dirname(filename)

def transformFlagPathsRelativeToAbsolute(flags, working_directory):
    relative_to_absolute = lambda path: os.path.join(os.path.abspath(working_directory), path)
    index = 0
    absolute_flags = []
    while index < len(flags):
        # If a flag is exactly equal to something in our PATH_FLAGS list, we can
        # assume that the following flag is the relevant path for the flag.
        # Advance the index forward twice because we just performed a readahead.
        if flags[index] in PATH_FLAGS:
            absolute_flags.append(flags[index])
            absolute_flags.append(relative_to_absolute(flags[index + 1]))
            index += 2
        # If a flag starts with something in PATH_FLAGS list, we can can
        # parition the string into the path-flag portion, and the path that is
        # relevant to the flag.
        # Advance the index forward once.
        elif any([flags[index].startswith(path_flag) for path_flag in PATH_FLAGS]):
            _, _, flag = flags[index].partition(path_flag)
            absolute_flags.append(path_flag + relative_to_absolute(flag))
            index += 1
        # Otherwise this flag was not related to a path at all, so we can add it
        # to our new list without modification.
        # Advance the index forward once.
        else:
            absolute_flags.append(flags[index])
            index += 1

def FlagsForFile(filename, **kwargs):
    flags, working_directory = getFileFlagsAndWorkingDirectory(filename)
    return {
        "flags": transformFlagPathsRelativeToAbsolute(flags, working_directory),
    }
